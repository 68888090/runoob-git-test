#include "client.h"



client::client(const char* ip) {
	fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	if (fd == INVALID_SOCKET)
	{
		printf("error\n socket()can`t create new socket\n");
	}

	struct sockaddr_in addr;
	addr.sin_family = AF_INET;
	addr.sin_port = htons(PORT);
	addr.sin_addr.S_un.S_addr = inet_addr(ip);//绑定ip地址
	if (INVALID_SOCKET == connect(fd, (struct sockaddr*)&addr, sizeof(addr)))
		printf("error\n connect()can`t create new socket\n");

	///////转换sockaddr_in到sockaddr类型

}
void main() {
	createinit();
	client Client("127.0.0.1");
	//SOCKET fd = accept(Client.fd, NULL, NULL);//完成连接
	//client clone;
	//clone.fd	=   accept(Sever.fd, NULL, NULL);////现在还没有进行初始化对象client
	//SOCKET fd = accept(Sever.fd, NULL, NULL);/////没有连接项所以进行了卡壳
	printf("created successfully,require connection\n");
	//char recvbuf[1024];
	//int ret;
	int i = 0;
	 require req[20];
	 for (int ij = 0; ij < 20; ij++)
	 {
		 strcpy(req[ij].method, "");
		 strcpy(req[ij].Cseq, "");
		 strcpy(req[ij].transport, "");
		 strcpy(req[ij].client_port, "");
		 strcpy(req[ij].Session_id, "");
		 strcpy(req[ij].ntp, "");
		 strcpy(req[ij].zhengwen, "");
	 }
	 require* p=NULL;
	 int recvtal=1;
	 char nh[4];
	// std::string str;
	
	while (1) {
	// memset(req[i].method, 0, 1024);

		std::cout << "请输入您的请求" << std::endl;
		inchars(req[i].method);
		//std::cin >> req[i].method;
		//std::string name{};
		//std::getline(std::cin >> std::ws, name);
		//scanf("%s", req[i].method);
		//getchar();
		//getchar();
		inchars(req[i].Cseq);

		//std::cin>> req[i].Cseq;
		//scanf("%s", req[i].Cseq);
		switch (*(req[i].method))
		{
		case 'O':
			//scanf("%s", req[i].zhengwen);
			inchars(req[i].zhengwen);

			//dCseq(&req[i], i);
			//std::cin >> req[i].zhengwen;
			//定义一个发送函数
			/// <summary>
				/// 再定义一个解析发送函数
				/// </summary>
			httpsend(Client.fd, req[i]);
			//////还没发
			if (SOCKET_ERROR == send(Client.fd, req[i].zhengwen, 1024, 0)) {

				printf("error\n send()can`t create new socket\n");
			}
			create(&p, req[i]);
			break;
		case 'S':
			inchars(req[i].transport);
			inchars(req[i].client_port);
			inchars(req[i].zhengwen);
	
			//std::cin >> req[i].transport >> req[i].client_port >> req[i].zhengwen;
			httpsend(Client.fd, req[i]);
			if (SOCKET_ERROR == send(Client.fd, req[i].transport, 1024, 0)) {

				printf("error\n send()can`t create new socket\n");
			}
			if (SOCKET_ERROR == send(Client.fd, req[i].client_port, 1024, 0)) {

				printf("error\n send()can`t create new socket\n");
			}
			if (SOCKET_ERROR == send(Client.fd, req[i].zhengwen, 1024, 0)) {

				printf("error\n send()can`t create new socket\n");
			}		
			create(&p, req[i]);
			break;
		case'P':
			inchars(req[i].Session_id);
			inchars(req[i].ntp);
			inchars(req[i].zhengwen);

			//std::cin >> req[i].Session_id >> req[i].ntp >> req[i].zhengwen;
			httpsend(Client.fd, req[i]);
			if (SOCKET_ERROR == send(Client.fd, req[i].Session_id, 1024, 0)) {

				printf("error\n send()can`t create new socket\n");
			}
			if (SOCKET_ERROR == send(Client.fd, req[i].ntp, 1024, 0)) {

				printf("error\n send()can`t create new socket\n");
			}
			if (SOCKET_ERROR == send(Client.fd, req[i].zhengwen, 1024, 0)) {

				printf("error\n send()can`t create new socket\n");
			}
			create(&p, req[i]);
			break;
		case'T':
			inchars(req[i].Session_id);
			inchars(req[i].zhengwen);

			//std::cin >> req[i].Session_id >> req[i].zhengwen;
			httpsend(Client.fd, req[i]);
			if (SOCKET_ERROR == send(Client.fd, req[i].Session_id, 1024, 0)) {

				printf("error\n send()can`t create new socket\n");
			}
			if (SOCKET_ERROR == send(Client.fd, req[i].zhengwen, 1024, 0)) {

				printf("error\n send()can`t create new socket\n");
			}
			create(&p, req[i]);
			break;
		case 'D':
			inchars(req[i].Session_id);
			httpsend(Client.fd, req[i]);
			if (SOCKET_ERROR == send(Client.fd, req[i].Session_id, 1024, 0)) {

				printf("error\n send()can`t create new socket\n");
			}
			create(&p, req[i]);
			break;
		default:
			std::cout << "请求无法被解析，请重试" << std::endl;
			
			break;

		}
	
		char recvvv[1024];

		switch (*(req[i].method))
		{
		case'O':
				recv(Client.fd, recvvv, 1024, 0);
				std::cout << recvvv << std::endl;////循环接收
				break;
		case 'S':
			recv(Client.fd, recvvv, 1024, 0);
			std::cout << recvvv << std::endl;////循环接收
	
			break;
		case'P':
			recv(Client.fd, recvvv, 1024, 0);
			std::cout << recvvv << std::endl;////循环接收
			for (int l = 0; l < 6; l++)
			{
				recv(Client.fd, recvvv, 1024, 0);
				std::cout << recvvv << std::endl;////循环接收
				Sleep(1000);
			}//////七次接收
			break;
		case'T':
			recv(Client.fd, recvvv, 1024, 0);
			std::cout << recvvv << std::endl;////循环接收


			goto A;
		case'D':
			
			recv(Client.fd, recvvv, 1024, 0);
			std::cout << recvvv << std::endl;////循环接收
			recv(Client.fd, nh, 1024, 0);
			//std::stringstream *ss;
			//*ss << nh;

			Sleep(500);
			if (!strcmp(recvvv, "匹配失败，session不符"))
			{
				break;
			}
			else
			{
				for (int il = 0; il < 4*7; il++)
				{
					recv(Client.fd, recvvv, 1024, 0);
					std::cout << recvvv << std::endl;////循环接收
				}
			}
			break;
		default:
			break;
		}
		
		i++;
		//getchar();
	}
	//ret = recv(Client.fd, recvbuf, 1024, 0);//////启动，但是recv的数据在哪不知
	//
 //                
	//std::cout << recvbuf << std::endl;
	//if (SOCKET_ERROR == send(Client.fd,"客户端接收到了您的请求", 48, 0)) {//////启动，但是send发送到何处不知
	//	printf("error\n send()can`t create new socket\n");
	//}//https://learn.microsoft.com/zh-cn/windows/win32/api/winsock2/nf-wi
	//
	//printf("created successfully,wait for connect\n");
	//if (ret == 0)
	//{
	//	printf("服务器正常下线\n");
	//}
	//else if (ret <= 0)
	//{
	//	printf("服务器非正常下线\n");
	//}
	//std::cout << "完成传输" << std::endl;
A:
	int watch = 0;
	std::cout << "是否查看历史记录,1为查看，其他为不查看" << std::endl;
	//存入数据

	std::cin >> watch;/////////////////////////////////////////////////存入文件
	if (watch==1)
	{
		printstruct(p);
	}getchar();
	//FILE* fp;
	//if ((fp = fopen("Cookie,txt", "wb")) == NULL)
	//{
	//	std::cout << "打开失败" << std::endl;
	//}
	//int session = 0;
	//fwrite(req[i].Session_id, sizeof(req[i].Session_id), 1, fp);
	//while (session < i)
	//{
	//	fwrite(&req[session], sizeof(require), 1, fp);
	//	session++;
	//}
	free(p);
	closesocket(Client.fd);
	//closeinit();                 
	getchar();
	//char  o = '\r\n';
}
